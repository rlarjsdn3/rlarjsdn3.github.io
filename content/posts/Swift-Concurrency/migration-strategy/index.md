---
date: '2025-10-30T13:31:19+09:00'
draft: false
title: '[번역] Swift Concurrency / Migration Strategy (Migrating to Swift 6)'
description: "프로젝트를 Swift 6 언어 모드로 마이그레이션하세요."
tags: ["", "", ""]
categories: ["Swift Concurrency"]
cover:
    image: images/code.jpg
    caption: ""
---


모듈에서 완전한 동시성 검사(complete concurrency checking)를 활성화하면 컴파일러가 수많은 데이터 경합 안정성 문제를 알려줄 수 있습니다. 수백 개, 심지어 수천 개의 경고가 발생하는 것도 드문 일이 아닙니다. 특히 Swift의 데이터 격리 모델을 막 배우기 시작한 단계라면, 이렇게 방대한 문제를 마주했을 때 감당하기 어려운 벽처럼 느껴질 수 있습니다.

**패닉에 빠지지 마세요.**

대부분의 경우, 몇 가지 변경만으로도 상단한 진전을 이루게 될 것입니다. 그리고 그렇게 진행하는 동안 Swift의 동시성 시스템이 어떻게 동작하는지에 대한 개념도 빠르게 습득할 수 있게 됩니다.

> **Important**:
> 이 가이드라인은 강력히 따라야 할 권장 사항으로 해석해서는 안 됩니다. 다른 접근 방식도 충분히 검토하고, 자신에게 맞는 접근을 선택하세요. 


## Strategy

이 문서는 좋은 출발점이 될 수 있는 일반적인 전략을 개략적으로 설명합니다. 모든 프로젝트에 똑같이 들어맞는 단일한 접근 방식은 존재하지 않습니다. 

이 접근 방식은 세 가지 핵심 단계로 이루어집니다.

* 모듈 선택하기

* Swift 5에서 더 엄격한 동시성 검사 활성화하기

* 경고 해결하기

이 과정은 본질적으로 반복적입니다. 하나의 모듈에서 단 한 가지 변경만 이루어져도 프로젝트 전체 상태에 큰 영향을 줄 수 있습니다.


## Begin from the Outside

프로젝트에서 가장 바깥쪽 루트 모듈에서 마이그레이션을 시작하는 것이 더 쉬울 수 있습니다. 가장 바깥쪽 루트 모듈은 다른 어떤 모듈이 의존하지 않기 때문에, 이곳에서의 변경은 국소적인 영향만 미치므로 작업을 해당 범위 안으로 제한할 수 있습니다.

그러나 변경 사항이 반드시 해당 모듈에만 국한될 필요는 없습니다. 여러분이 관리하는 의존성 중 [안전하지 않은 전역 상태]()나 [사소하게 `Sendable` 타입]()이 있는 경우, 이는 프로젝트 전반에 걸쳐 많은 경고의 근본 원인이 될 수 있습니다. 이러한 부분을 우선적으로 집중해서 해결하는 것이 효과적일 때가 많습니다.


## Use the Swift 5 Language Mode

아무런 검증을 거치지 않고 Swift 5에서 곧바로 Swift 6 언어 모드로 프로젝트를 옮기는 것은 꽤 어려운 일일 수 있습니다. 대신 Swift 5 언어 모드를 유지하면서 점진적으로 Swift 6의 동시성 검사 메커니즘을 강화하도록 할 수 있습니다. 이렇게 하면 문제들이 경고로만 표시되므로, 마이그레이션을 진행하는 동안 빌드와 테스트를 정상적으로 동작하는 상태를 유지할 수 있습니다.

먼저, 수 많은 동시성 기능 중 하나만 활성화하세요. 이렇게 하면 한 번에 하나의 특정 문제 유형에만 집중할 수 있습니다.

| Proposal | Description | Feature Flag |
| :--:     | :--:        | :--:         |
| [SE-0401]() | 프로퍼티 래퍼로 인해 발생하는 액터 격리 추론 제거 | DisableOutwardActorInference |
| [SE-0412]() | 전역 변수에 대한 엄격한 동시성 | GlobalConcurrency | 
| [SE-0418]() | 메서드와 키 패스 리터럴에 대한 `Sendable` 추론 | InferSendableFromCaptures |

이 기능들은 서로 독립적으로, 그리고 어떤 순서로든 활성화할 수 있습니다.

기능 플래그를 활성화해 드러난 문제들을 해결한 뒤, 다음 단계는 모듈에 대해 [완전한 검사를 활성화]()하는 것입니다. 이렇게 하면 컴파일러가 나머지 모든 데이터 격리 검사를 수행하게 됩니다.


## Address Warnings

경고를 확인할 때 따라야 할 하나의 핵심 원칙은 **현재 사실을 표현하라(코드가 실제로 지금 어떤 격리 상태에 있는지, 어떤 동시성 제약을 갖는지를 사실 그대로 받아들이고, 무리하게 코드 구조를 바꾸지 말라)**는 것입니다. 문제를 해결하기 위해 코드를 리팩토링하고 싶은 충동을 억제하세요.

완전한 동시성 검사를 통해 경고가 없는 상태에 도달할 때까지 필요한 변경을 최소화하는 것이 좋습니다. 그 후에 적용했던 안전하지 않은 예외(opt-out)들은, 더 안전한 격리 메커니즘을 도입하기 위한 후속 리팩토링 기회로 삼으세요.

> **Note**: 
> 자주 발생하는 컴파일러 오류를 해결하는 방법에 대해 알아보려면 [자주 발생하는 컴파일러 오류]()를 참고하세요.


## Iteration

처음에는 데이터 격리 문제를 해결하기 위해 규칙을 비활성하거나 임시 방편으로 넘어가는 경우가 많을 것입니다. 하지만 상위 모듈에서 더 이상 진전이 어렵다고 느껴지만, 그 동안 임시 해결책에 의존해야 했던 하위 모듈 중 하나를 선택해 본격적으로 수정해 나가세요.

모든 경고를 전부 없애야만 다음 단계로 넘어갈 필요는 없습니다. 아주 작은 변경만으로도 큰 영향을 줄 수 있다는 점을 기억하세요. 또한 의존하던 모듈 중 하나가 업데이트되면, 언제든 다시 해당 모듈로 돌아와 작업을 이어갈 수 있습니다.